!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).marmot = t() }(this, (function () {
    "use strict"; function e(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e }
/**
	 * [@uking/marmot]{@link https://github.com/An-uking/marmot.git}
	 *
	 * @namespace marmot
	 * @version 1.1.6
	 * @author uking [ptvile@live.com]
	 * @copyright uking 2024
	 * @license MIT
	 */const t = { V_IF: "v-if", V_ELSE_IF: "v-else-if", V_ELSE: "v-else", V_FOR: "v-for" }, n = { script: 1, style: 1, template: 1, textarea: 1, pre: 1, code: 1, noscript: 1, noframes: 1, iframe: 1 }, s = { area: 1, base: 1, br: 1, col: 1, embed: 1, hr: 1, img: 1, input: 1, link: 1, meta: 1, param: 1, command: 1, keygen: 1, source: 1, track: 1, wbr: 1, menuitem: 1, frame: 1 }, r = /\{\{(.*?)}}/g, l = ["Template", "Slot"], i = new Error("v-for must have source and value."); const o = (e, t, n, s, r) => { let { s: l, v: i } = e; if (i.length) throw Error("not support dynamic value in template"); return a(l[0].replace(/\n\s+/g, ""), t, n, s, r) }; function a(e, t, l, o, b) { let w = ""; b = b || {}, o = o || {}, t = t || {}, l = l || {}; let $ = /<([A-Za-z!][A-Za-z0-9-]*)/g, O = /<([A-Z]\w*)/g, j = $.exec(e), y = null; if (j) for (; j;) { if (j.index > 0) { w += a(e.substring(0, j.index), t, l, o, b), e = e.substring(j.index), $.lastIndex = 0, j = $.exec(e); continue } let _ = j[1], I = -1, S = "", V = "", F = !1, k = !1; if ("!--" === _) { S = "--\x3e", I = e.indexOf(S) + S.length, w += e.substring(0, I), e = e.substring(I), $.lastIndex = 0, j = $.exec(e); continue } "!DOCTYPE" === _ ? (k = !1, S = ">", I = e.indexOf(S) + S.length, V = e.substring(0, I), F = !0) : (I = g(e), k = /^[A-Z]/.test(_), V = e.substring(0, I), F = k ? V.endsWith("/>") : 1 === s[_], S = F ? "/>" : ">"); let C = E(V), T = f(C.if, y, l, o); if (y = T.ifCondition, T.condition) { if (F) if ("Slot" === _) { let e = C.attrs.name ? C.attrs.name.value : "default"; w += b[e] || "", b[e] = "" } else if (C.for) { let e = c(C.for); if (!e.sourceExp || !e.valueExp) throw i; let n = l[e.sourceExp] || p(e.sourceExp); for (let s in n) { let r = {}; e.indexExp && (r[e.indexExp] = x(s)), r[e.valueExp] = n[s]; let i = v(C.attrs, r, o); r = Object.assign(r, i), w += k ? d(_, t, r, o, b) : m(_, C.attrs, S, Object.assign(r, l), o) } } else if (k) { let e = v(C.attrs, l, o); w += d(_, t, Object.assign({}, l, e), o, b) } else w += m(_, C.attrs, S, l, o); else { let s = "Template" === _, f = `</${_}>`, g = h(e.substring(I), _); if (-1 === g) throw new Error(`End tag ${f} not found.`); g += I; let E = e.substring(I, g); if (k) { let e = C.attrs.slot ? C.attrs.slot.value : "default", n = ""; if (C.for) { let e = c(C.for); if (!e.sourceExp || !e.valueExp) throw i; let s = l[e.sourceExp] || p(e.sourceExp); for (let r in s) { let i = {}; e.indexExp && (i[e.indexExp] = x(r)), i[e.valueExp] = s[r]; let u = v(C.attrs, i, o); i = Object.assign(i, u, l), n += a(E, t, i, o, b) } } else n = a(E, t, l, o, b); if (b[e] = n, !s) { let e = v(C.attrs, l, o); w += d(_, t, Object.assign({}, l, e), o, b) } } else if (1 === n[_]) w += m(_, C.attrs, S, l, o), w += E.replace(r, ((e, t) => u(t, l, o))), w += `</${_}>`; else if (C.for) { let e = c(C.for); if (!e.sourceExp || !e.valueExp) throw i; let n = l[e.sourceExp] || p(e.sourceExp); for (let s in n) { let r = {}; e.indexExp && (r[e.indexExp] = x(s)), r[e.valueExp] = n[s]; let l = v(C.attrs, r, o); r = Object.assign(r, l), w += m(_, C.attrs, S, r, o), w += a(E, t, r, o, b), w += `</${_}>` } } else w += m(_, C.attrs, S, l, o), w += a(E, t, l, o, b), w += `</${_}>`; I = g + f.length } e = e.substring(I), $.lastIndex = 0, O.lastIndex = 0, j = $.exec(e), !j && e && (w += a(e, t, l, o, b)) } else e = e.substring(I), $.lastIndex = 0, j = $.exec(e) } else w += e.replace(r, ((e, t) => u(t, l, o))); return w } function u(e, t, n) { let s = { __c: n }; s = Object.assign(s, t); let r = Object.keys(s), l = Object.values(s); return new Function(...r, `return ${e}`)(...l) } function f(e, n, s, r) { let l = !0; if (e) if (e.name === t.V_IF) l = n = u(e.value, s, r); else if (e.name === t.V_ELSE_IF) { if (null === n) throw new Error("previous node missing v-if"); l = n ? !n : n = u(e.value, s, r) } else { if (null === n) throw new Error("previous node missing v-if or v-else-if"); l = !n } else n = null; return { ifCondition: n, condition: l } } function c(e) { let t = /^\(|\)$/g, n = /,([^,}\]]*)(?:,([^,}\]]*))?$/, s = e.match(/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/), r = null, l = null, i = null; if (s) { r = s[2].trim(), l = s[1].trim().replace(t, "").trim(); let e = l.match(n); e && (l = l.replace(n, "").trim(), i = e[1].trim()) } return { sourceExp: r, valueExp: l, indexExp: i } } function p(e) { let t = parseInt(e); return isNaN(t) || t < 1 ? [] : Array.from({ length: t }, ((e, t) => t + 1)) } function x(e) { let t = parseInt(e); return isNaN(t) ? e : t } function d(e, t, n, s, r) { let l = t[e]; if (!l) throw new Error(`Component ${e} not found.`); let i = new l(s), a = Object.assign({}, n, i.data); return o(i.render(), i.components(), a, i.context, r) } function h(e, t) { let n = new RegExp(`<${t}`, "g"), s = new RegExp(`</${t}>`, "g"), r = new RegExp(`</${t}>`, "g"), l = s.exec(e); if (!l) return -1; for (; l;) { let t = e.slice(0, l.index), i = t.match(n), o = t.match(r); if (!i && (i = []), !o && (o = []), i.length === o.length) return l.index; l = s.exec(e) } return -1 } function g(e) { let t = -1, n = /(\/)?>/g, s = /(")/g, r = /(')/g, l = n.exec(e); for (; l;) { let i = e.substring(0, l.index + l[0].length), o = i.match(s), a = i.match(r); if (!o && (o = []), !a && (a = []), o.length % 2 == 0 && a.length % 2 == 0) { t = l.index + l[0].length; break } l = n.exec(e) } if (-1 === t) throw new Error("Invalid HTML"); return t } function E(e) { let n = { hasExp: !1, if: null, for: null, attrs: {} }, s = e.match(/([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"|'([^']*)'|([^\s"'=<>`]+)))?/g); for (let e = 1; e < s.length; e++) { let r = s[e], l = [], i = r.indexOf("="); -1 === i ? l.push(r) : (l.push(r.substring(0, i)), l.push(r.substring(i + 1))); let o = l[0], a = o === t.V_ELSE ? null : !(l.length > 1) || l[1].slice(1, -1); o.startsWith(":") ? (!n.hasExp && (n.hasExp = !0), n.attrs[o] = { value: a, isExp: !0 }) : o.startsWith("v-") ? o === t.V_FOR ? n.for = a : n.if = { name: o, value: a } : n.attrs[o] = { value: a, isExp: !1 } } return n } function m(e, t, n, s, r) { let l = [], i = []; l.push(`<${e}`); for (let e in t) if (e.includes("class")) if (e.includes(":")) { let n = t[e].value, l = "class" === n ? "" : u(n, s, r); if ("object" === typeof l) for (let e in l) l[e] && i.push(e); else { let e = l.replace(/^\s+|\s+$/g, "").split(/\s+/g); i.push(...e) } } else { let n = t[e].value.replace(/^\s+|\s+$/g, "").split(/\s+/g); i.push(...n) } else if (e.includes(":")) { let n = t[e].value; e = e.slice(1); let i = u(n, s, r); "boolean" === typeof i ? i && l.push(e) : l.push(`${e}="${i}"`) } else { let n = t[e].value; "boolean" === typeof n ? n && l.push(e) : l.push(`${e}="${n}"`) } return i.length && l.push(`class="${i.join(" ")}"`), l.join(" ") + n } function v(e, t, n) { let s = {}; for (let r in e) { let l = e[r].value; r.startsWith(":") ? s[r.slice(1)] = u(l, t, n) : s[r] = l } return s } return e({ render: o, Component: class { constructor(e = {}) { this.context = e || {}; let t = this.constructor.name; if (l.includes(t)) throw new Error(`Component ${t} is a reserved keyword.`); this.data = this.data() || {}, this.data = Object.assign(this.data, this.functions() || {}) } functions() { } data() { } components() { } render() { } }, html: (e, ...t) => ({ s: e, v: t }) })
}));
